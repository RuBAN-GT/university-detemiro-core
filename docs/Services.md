# Сервисы

Сервисы - это [регистр](Registry), в котором можно задать способ создания ключа.

Чаще всего - это инициализация объекта. Это полезно в тех ситуациях, когда этот объект или другие данные ключа могут быть не использованными при запросе пользователя. Например, вы создатите объект для работы с БД и решите выдать пользователю статичную информацию - 404 страницу. Если поместить данную логику в сервисы, то она использоваться не будет.

> Сервисы можно использовать как регистр.

## <a name="realisation"></a>Реализация
Сервисы для ядра представлены классом [serviceContainer](https://docs.detemiro.org/api/classes/detemiro.serviceContainer.html), и их объект находится в поле [$services](https://docs.detemiro.org/api/classes/detemiro.html#property_services), внутри класса *detemiro*.

## <a name="features"></a>Особенности
Класс *detemiro* при вызове неопределённого статического метода возвращает значение ключа сервиса с именем этого метода.
Например, при вызове *detemiro::db()* результатом будет являться *detemiro::services()->get('db')*.

Данная особенность упрощает написание. Если вы убеждены, что работы с нужным сервисом, и он определён, можно смело писать:

~~~~php
detemiro::db()->deleteTable('other');
~~~~

Причём при вызове, когда объекта ещё не существует, можно в такой магический метод поместить аргументы, которые попадут в инициализирующую функцию.

~~~~php
detemiro::db('mysql:host=localhost;dbname=data')->select(array('table' => 'main'));
~~~~

При такой конструкции, если не существует данных под ключом *db*, PDO-строка попадёт в функцию, которая создаёт объект. Т.к. результатом будет являться объект (в случае успеха), можно сразу вызывать его метод.

> Хоть вы и можете использовать данную конструкцию в чистом виде, всё же желательно её обернуть или в try/catch, или всё-таки разбить на две операции, т.к. инициализирующая функция может не вернуть объект.

## <a name="examples"></a>Примеры использования
А теперь можно поэкспериментировать с сервисами.

~~~~php
// Задаём тестовый класс
class test {
    protected $param = null;
    
    public function __construct($param) {
        $this->param = $param;
        
        $this->main();
    }
    public function main() {
        print_r($this->param);
    }
}
~~~~

Добавляем ключ с инициализирующей анонимной функцией:

~~~~php
detemiro::services()->set('test', function($arg) {
    return new test($arg);
}, false, true);
~~~~

Получим объект 'test':

~~~~php
detemiro::test(1);

// Аналогично
// detemiro::services()->get('test', 1);
~~~~

*Выведет "1"*

Вызовем метод main у нового объекта, которым выведет "1":

~~~~php
detemiro::test()->main();

// Аналогично
// detemiro::services()->get('test')->main();
~~~~

Получим новый объект класса 'test'

~~~~php
$new = detemiro::services()->init(2);
~~~~

*Конструктор выведет 2, а $new будет являться новой переменной с независимым объектом.*

Обновим значение `test`, переинициализировав его.

~~~~php
detemiro::services()->initValue('test', 3);
~~~~
*Теперь конструктор нового объекта под ключом `test` выведет 3.*